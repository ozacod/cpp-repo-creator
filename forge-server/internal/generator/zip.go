package generator

import (
	"archive/zip"
	"bytes"
	"fmt"

	"github.com/ozacod/forge/forge-server/internal/recipe"
)

func CreateProjectZip(
	projectName string,
	cppStandard int,
	librarySelections []LibrarySelection,
	includeTests bool,
	testingFramework string,
	buildShared bool,
	clangFormatStyle string,
	projectType string,
	projectVersion string,
	flat bool,
	loader *recipe.Loader,
) ([]byte, error) {
	// Get library objects with their options
	var librariesWithOptions []LibraryWithOptions
	var allLibraries []*recipe.Library

	for _, selection := range librarySelections {
		lib, err := loader.GetLibraryByID(selection.LibraryID)
		if err != nil {
			continue
		}
		if lib != nil {
			options := selection.Options
			if options == nil {
				options = make(map[string]any)
			}
			librariesWithOptions = append(librariesWithOptions, LibraryWithOptions{
				Lib:     lib,
				Options: options,
			})
			allLibraries = append(allLibraries, lib)
		}
	}

	// Separate test libraries from main libraries
	var testLibraries, mainLibraries []LibraryWithOptions
	for _, lwo := range librariesWithOptions {
		if lwo.Lib.Category == "testing" {
			testLibraries = append(testLibraries, lwo)
		} else {
			mainLibraries = append(mainLibraries, lwo)
		}
	}

	// Add selected testing framework if not already present
	if includeTests && testingFramework != "" && testingFramework != "none" {
		existingTestIDs := make(map[string]bool)
		for _, lwo := range testLibraries {
			existingTestIDs[lwo.Lib.ID] = true
		}
		if !existingTestIDs[testingFramework] {
			testLib, err := loader.GetLibraryByID(testingFramework)
			if err == nil && testLib != nil {
				testLibraries = append([]LibraryWithOptions{{Lib: testLib, Options: map[string]any{}}}, testLibraries...)
			}
		}
	}

	testLibsOnly := make([]*recipe.Library, 0, len(testLibraries))
	for _, lwo := range testLibraries {
		testLibsOnly = append(testLibsOnly, lwo.Lib)
	}

	// Create in-memory ZIP file
	var zipBuffer bytes.Buffer
	zw := zip.NewWriter(&zipBuffer)

	// Use empty prefix for flat mode (CLI), project_name for wrapped mode (web UI)
	prefix := ""
	if !flat {
		prefix = projectName + "/"
	}

	// Only generate dependencies.cmake - all other files are generated by the client
	// The client (forge-client/generator.go) generates all project files locally
	// and only requests dependencies.cmake from the server (which requires recipe data)
	depsCMake, err := GenerateDependenciesCMake(librariesWithOptions, includeTests, testingFramework, loader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate dependencies.cmake: %w", err)
	}
	if err := writeZipFile(zw, prefix+".cmake/forge/dependencies.cmake", depsCMake); err != nil {
		return nil, err
	}

	if err := zw.Close(); err != nil {
		return nil, fmt.Errorf("failed to close zip writer: %w", err)
	}

	return zipBuffer.Bytes(), nil
}

func writeZipFile(zw *zip.Writer, name, content string) error {
	w, err := zw.Create(name)
	if err != nil {
		return fmt.Errorf("failed to create zip entry %s: %w", name, err)
	}
	_, err = w.Write([]byte(content))
	if err != nil {
		return fmt.Errorf("failed to write zip entry %s: %w", name, err)
	}
	return nil
}
