package generator

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/ozacod/forge/forge-server/internal/recipe"
)

type LibrarySelection struct {
	LibraryID string         `json:"library_id"`
	Options   map[string]any `json:"options"`
}

func GenerateDependenciesCMake(
	librariesWithOptions []LibraryWithOptions,
	includeTests bool,
	testingFramework string,
	loader *recipe.Loader,
) (string, error) {
	// Separate test libraries from main libraries
	var testLibraries, mainLibraries []LibraryWithOptions
	for _, lwo := range librariesWithOptions {
		if lwo.Lib.Category == "testing" {
			testLibraries = append(testLibraries, lwo)
		} else {
			mainLibraries = append(mainLibraries, lwo)
		}
	}

	// Add selected testing framework if not already present
	if includeTests && testingFramework != "" && testingFramework != "none" {
		existingTestIDs := make(map[string]bool)
		for _, lwo := range testLibraries {
			existingTestIDs[lwo.Lib.ID] = true
		}
		if !existingTestIDs[testingFramework] {
			testLib, err := loader.GetLibraryByID(testingFramework)
			if err == nil && testLib != nil {
				testLibraries = append([]LibraryWithOptions{{Lib: testLib, Options: map[string]any{}}}, testLibraries...)
			}
		}
	}

	var sb strings.Builder
	sb.WriteString(`# =============================================================================
# dependencies.cmake - Generated by Forge
# This file is auto-generated. Regenerate with 'forge generate' to update.
# =============================================================================

include(FetchContent)

`)

	// Add FetchContent declarations for main libraries
	if len(mainLibraries) > 0 {
		sb.WriteString(`# -----------------------------------------------------------------------------
# Main Dependencies
# -----------------------------------------------------------------------------

`)
		for _, lwo := range mainLibraries {
			cmake, err := generateLibraryCMake(lwo.Lib, lwo.Options)
			if err != nil {
				return "", err
			}
			sb.WriteString(cmake)
			sb.WriteString("\n")
		}
	}

	// Add test library FetchContent
	if includeTests && len(testLibraries) > 0 {
		sb.WriteString(`# -----------------------------------------------------------------------------
# Test Dependencies
# -----------------------------------------------------------------------------

`)
		for _, lwo := range testLibraries {
			cmake, err := generateLibraryCMake(lwo.Lib, lwo.Options)
			if err != nil {
				return "", err
			}
			sb.WriteString(cmake)
			sb.WriteString("\n")
		}
	}

	// Collect link libraries
	mainLinkLibs := collectLinkLibraries(mainLibraries)
	testLinkLibs := collectLinkLibraries(testLibraries)

	// Add link library variables
	sb.WriteString(`# -----------------------------------------------------------------------------
# Link Libraries (used by CMakeLists.txt)
# -----------------------------------------------------------------------------

`)

	if len(mainLinkLibs) > 0 {
		sb.WriteString("set(FORGE_LINK_LIBRARIES\n")
		for _, lib := range mainLinkLibs {
			sb.WriteString(fmt.Sprintf("    %s\n", lib))
		}
		sb.WriteString(")\n\n")
	} else {
		sb.WriteString("set(FORGE_LINK_LIBRARIES)\n\n")
	}

	if len(testLinkLibs) > 0 {
		sb.WriteString("set(FORGE_TEST_LINK_LIBRARIES\n")
		for _, lib := range testLinkLibs {
			sb.WriteString(fmt.Sprintf("    %s\n", lib))
		}
		sb.WriteString(")\n")
	} else {
		sb.WriteString("set(FORGE_TEST_LINK_LIBRARIES)\n")
	}

	return sb.String(), nil
}

type LibraryWithOptions struct {
	Lib     *recipe.Library
	Options map[string]any
}

func GenerateCMakeLists(
	projectName string,
	cppStandard int,
	librariesWithOptions []LibraryWithOptions,
	includeTests bool,
	testingFramework string,
	buildShared bool,
	projectType string,
	projectVersion string,
	loader *recipe.Loader,
) (string, error) {
	// Find maximum required C++ standard
	maxStandard := cppStandard
	for _, lwo := range librariesWithOptions {
		if lwo.Lib.CppStandard > maxStandard {
			maxStandard = lwo.Lib.CppStandard
		}
	}

	// Separate test libraries from main libraries
	var testLibraries, mainLibraries []LibraryWithOptions
	for _, lwo := range librariesWithOptions {
		if lwo.Lib.Category == "testing" {
			testLibraries = append(testLibraries, lwo)
		} else {
			mainLibraries = append(mainLibraries, lwo)
		}
	}

	// Add selected testing framework if not already present
	if includeTests && testingFramework != "" && testingFramework != "none" {
		existingTestIDs := make(map[string]bool)
		for _, lwo := range testLibraries {
			existingTestIDs[lwo.Lib.ID] = true
		}
		if !existingTestIDs[testingFramework] {
			testLib, err := loader.GetLibraryByID(testingFramework)
			if err == nil && testLib != nil {
				testLibraries = append([]LibraryWithOptions{{Lib: testLib, Options: map[string]any{}}}, testLibraries...)
				if testLib.CppStandard > maxStandard {
					maxStandard = testLib.CppStandard
				}
			}
		}
	}

	buildSharedStr := "OFF"
	if buildShared {
		buildSharedStr = "ON"
	}

	// Use version from forge.yaml or default
	version := projectVersion
	if version == "" {
		version = "1.0.0"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf(`cmake_minimum_required(VERSION 3.20)
project(%s VERSION %s LANGUAGES CXX)

# Set C++ standard
set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Export compile commands for IDE support
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Build options
option(BUILD_SHARED_LIBS "Build shared libraries" %s)

# =============================================================================
# Dependencies (managed by Forge - regenerate with 'forge generate')
# =============================================================================
include(${CMAKE_CURRENT_SOURCE_DIR}/.cmake/forge/dependencies.cmake)

# =============================================================================
# Version Header Generation (managed by Forge)
# =============================================================================
include(${CMAKE_CURRENT_SOURCE_DIR}/.cmake/forge/utils.cmake)
forge_configure_version_header(%s)

`, projectName, version, maxStandard, buildSharedStr, projectName))

	if projectType == "exe" {
		sb.WriteString(fmt.Sprintf(`# =============================================================================
# Main Executable
# =============================================================================

add_executable(%s
    src/main.cpp
    src/%s.cpp
)

target_include_directories(%s
    PRIVATE
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
)

target_link_libraries(%s
    PRIVATE
        ${FORGE_LINK_LIBRARIES}
)

`, projectName, projectName, projectName, projectName))
	} else {
		sb.WriteString(fmt.Sprintf(`# =============================================================================
# Main Library
# =============================================================================

add_library(%s
    src/%s.cpp
)

target_include_directories(%s
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
)

target_link_libraries(%s
    PUBLIC
        ${FORGE_LINK_LIBRARIES}
)

`, projectName, projectName, projectName, projectName))
		sb.WriteString(`# =============================================================================
# Installation
# =============================================================================

install(TARGETS ` + projectName + `
    EXPORT ` + projectName + `Targets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    INCLUDES DESTINATION include
)

install(DIRECTORY include/ DESTINATION include)

`)
	}

	// Test configuration
	if includeTests && len(testLibraries) > 0 {
		sb.WriteString(`# =============================================================================
# Testing
# =============================================================================

enable_testing()

add_subdirectory(tests)
`)
	}

	return sb.String(), nil
}

func generateLibraryCMake(lib *recipe.Library, options map[string]any) (string, error) {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# %s\n", lib.Name))

	// Generate CMake variables from options
	for _, opt := range lib.Options {
		optValue, ok := options[opt.ID]
		if !ok {
			optValue = opt.Default
		}
		if optValue == nil {
			continue
		}

		// Handle cmake_var
		if opt.CMakeVar != "" {
			switch opt.Type {
			case "boolean":
				cmakeVal := "OFF"
				if b, ok := optValue.(bool); ok && b {
					cmakeVal = "ON"
				}
				sb.WriteString(fmt.Sprintf("set(%s %s)\n", opt.CMakeVar, cmakeVal))
			case "string":
				if s, ok := optValue.(string); ok && s != "" {
					sb.WriteString(fmt.Sprintf("set(%s \"%s\")\n", opt.CMakeVar, s))
				}
			case "integer":
				sb.WriteString(fmt.Sprintf("set(%s %v)\n", opt.CMakeVar, optValue))
			case "choice":
				if s, ok := optValue.(string); ok {
					sb.WriteString(fmt.Sprintf("set(%s \"%s\")\n", opt.CMakeVar, s))
				}
			}
		}
	}

	// Add cmake_pre if present
	if lib.CMakePre != "" {
		sb.WriteString(lib.CMakePre)
		sb.WriteString("\n")
	}

	// System package (find_package)
	if lib.SystemPackage {
		pkgName := lib.FindPackageName
		if pkgName == "" {
			pkgName = lib.Name
		}
		sb.WriteString(fmt.Sprintf("find_package(%s REQUIRED)\n", pkgName))
	} else {
		// FetchContent
		if lib.FetchContent != nil {
			sb.WriteString("FetchContent_Declare(\n")
			sb.WriteString(fmt.Sprintf("    %s\n", lib.ID))
			sb.WriteString(fmt.Sprintf("    GIT_REPOSITORY %s\n", lib.FetchContent.Repository))
			sb.WriteString(fmt.Sprintf("    GIT_TAG %s\n", lib.FetchContent.Tag))
			if lib.FetchContent.SourceSubdir != "" {
				sb.WriteString(fmt.Sprintf("    SOURCE_SUBDIR %s\n", lib.FetchContent.SourceSubdir))
			}
			sb.WriteString(")\n")
			sb.WriteString(fmt.Sprintf("FetchContent_MakeAvailable(%s)\n", lib.ID))
		}
	}

	// Add cmake_post if present
	if lib.CMakePost != "" {
		sb.WriteString(lib.CMakePost)
		sb.WriteString("\n")
	}

	// Generate compile definitions from options
	for _, opt := range lib.Options {
		optValue, ok := options[opt.ID]
		if !ok {
			optValue = opt.Default
		}
		if opt.CMakeDefine != "" && optValue != nil {
			switch opt.Type {
			case "boolean":
				if b, ok := optValue.(bool); ok && b {
					sb.WriteString(fmt.Sprintf("add_compile_definitions(%s)\n", opt.CMakeDefine))
				}
			case "integer":
				sb.WriteString(fmt.Sprintf("add_compile_definitions(%s=%v)\n", opt.CMakeDefine, optValue))
			case "string", "choice":
				if s, ok := optValue.(string); ok && s != "" {
					sb.WriteString(fmt.Sprintf("add_compile_definitions(%s=%s)\n", opt.CMakeDefine, s))
				}
			}
		}
	}

	return sb.String(), nil
}

func collectLinkLibraries(librariesWithOptions []LibraryWithOptions) []string {
	linkLibs := make(map[string]bool)
	var result []string

	for _, lwo := range librariesWithOptions {
		// Base link libraries
		for _, lib := range lwo.Lib.LinkLibraries {
			if !linkLibs[lib] {
				linkLibs[lib] = true
				result = append(result, lib)
			}
		}

		// Check options that affect linking
		for _, opt := range lwo.Lib.Options {
			optValue, ok := lwo.Options[opt.ID]
			if !ok {
				optValue = opt.Default
			}
			if opt.AffectsLink && optValue != nil {
				if b, ok := optValue.(bool); ok && b {
					for _, additionalLib := range opt.LinkLibrariesWhenEnabled {
						if !linkLibs[additionalLib] {
							linkLibs[additionalLib] = true
							result = append(result, additionalLib)
						}
					}
				}
			}
		}
	}

	return result
}

var projectNameRegex = regexp.MustCompile(`^[a-zA-Z][a-zA-Z0-9_]*$`)

func ValidateProjectName(name string) bool {
	return projectNameRegex.MatchString(name)
}

// GenerateUtilsCMake generates the utils.cmake file for version header configuration
func GenerateUtilsCMake() string {
	return `# =============================================================================
# Forge Utils - Version Header Generation
# =============================================================================
# This file is auto-generated by Forge. Do not edit manually.
# Regenerate with 'forge generate' to update.

function(forge_configure_version_header PROJECT_NAME)
    # Include version from forge.yaml (generated by forge generate)
    include(${CMAKE_CURRENT_SOURCE_DIR}/.cmake/forge/version.cmake)
    
    string(TOUPPER "${PROJECT_NAME}" PROJECT_NAME_UPPERCASE)
    
    # Parse version components from FORGE_PROJECT_VERSION
    string(REGEX REPLACE "^([0-9]+)\\..*" "\\1" PROJECT_VERSION_MAJOR "${FORGE_PROJECT_VERSION}")
    string(REGEX REPLACE "^[0-9]+\\.([0-9]+).*" "\\1" PROJECT_VERSION_MINOR "${FORGE_PROJECT_VERSION}")
    string(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" PROJECT_VERSION_PATCH "${FORGE_PROJECT_VERSION}")
    
    # Set default values if parsing failed
    if("${PROJECT_VERSION_MAJOR}" STREQUAL "")
        set(PROJECT_VERSION_MAJOR "0")
    endif()
    if("${PROJECT_VERSION_MINOR}" STREQUAL "")
        set(PROJECT_VERSION_MINOR "0")
    endif()
    if("${PROJECT_VERSION_PATCH}" STREQUAL "")
        set(PROJECT_VERSION_PATCH "0")
    endif()
    
    # Set PROJECT_VERSION for template substitution
    set(PROJECT_VERSION "${FORGE_PROJECT_VERSION}")
    
    # Configure version header from template
    configure_file(
        "${CMAKE_CURRENT_SOURCE_DIR}/.cmake/forge/version.hpp.in"
        "${CMAKE_CURRENT_SOURCE_DIR}/include/${PROJECT_NAME}/version.hpp"
        @ONLY
    )
endfunction()
`
}

// GenerateVersionCMake generates the version.cmake file with version from forge.yaml
func GenerateVersionCMake(projectVersion string) string {
	if projectVersion == "" {
		projectVersion = "1.0.0"
	}
	return fmt.Sprintf(`# =============================================================================
# Version from forge.yaml
# =============================================================================
# This file is auto-generated by Forge from forge.yaml package.version
# Do not edit manually. Regenerate with 'forge generate' to update.

set(FORGE_PROJECT_VERSION "%s")
`, projectVersion)
}

// GenerateVersionHppIn generates the version.hpp.in template file
func GenerateVersionHppIn() string {
	return `#ifndef @PROJECT_NAME_UPPERCASE@_VERSION_H_
#define @PROJECT_NAME_UPPERCASE@_VERSION_H_

#define @PROJECT_NAME_UPPERCASE@_VERSION "@PROJECT_VERSION@"
#define @PROJECT_NAME_UPPERCASE@_MAJOR_VERSION @PROJECT_VERSION_MAJOR@
#define @PROJECT_NAME_UPPERCASE@_MINOR_VERSION @PROJECT_VERSION_MINOR@
#define @PROJECT_NAME_UPPERCASE@_PATCH_VERSION @PROJECT_VERSION_PATCH@

#endif  // @PROJECT_NAME_UPPERCASE@_VERSION_H_
`
}
